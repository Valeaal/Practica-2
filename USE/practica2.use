model Practica2

-- Reloj para apartado C --

class Clock 
  attributes
    NOW : Integer init = 0
    resolution: Integer init = 1 
  operations
    tick() 
      begin
        self.NOW:=self.NOW + self.resolution;
        for o in self.ao do 
            o.tick()
        end;
      end
    run (n:Integer)
      begin
        for i in Sequence{1..n} do
          self.tick()
        end 
      end
end

abstract class ActiveObject
  operations
    tick() begin end 
end

association Time between 
  Clock [1] 
  ActiveObject [*] role ao ordered
end

----------------------------

class Estacion
    attributes
    aforo : Integer
    isEndOfTheLine : Boolean derive: 
        self.viaIda->iterate(viaIda ; suma : Integer = 0 | suma+1) + + self.viaVuelta->iterate(viaVuelta ; suma : Integer = 0 | suma+1) = 2
        
end

class Tren < ActiveObject
    attributes
        direccion : Real init: 1   
        stopTime : Integer init: 0
        movingTime : Integer init: 0
        isMoving : Boolean init: false
        isOutOfOrder : Boolean init: false
    operations   
        move()
        begin
            self.isMoving:=true;
        end
        stop()
        begin
            self.isMoving:=false;
        end
        tick()
        begin
        --declare segmentoACoger : Segmento;
        --declare nextStation : Estacion;
        declare viaAnterior : Via;
        viaAnterior := self.viaDelTren;
            if (self.isMoving) then
                self.movingTime := self.movingTime + self.clock.resolution;
                -- Los trenes deben tardar 2 min entre estación y estación
                if (self.movingTime) = 120 then
                    self.movingTime := 0;
                    if (self.direccion=1) then
                        --nextStation := self.viaDelTren.estacionVuelta;
                        delete (self,self.estacionDelTren) from trenEstacion;
                        insert (self,self.viaDelTren.estacionVuelta) into trenEstacion; --self,nextStation
                        delete (self,self.viaDelTren) from trenVia;
                        if (self.estacionDelTren.isEndOfTheLine) then
                            self.direccion:=self.direccion*-1;
                            insert (self,self.estacionDelTren.viaIda->asSequence()->first()) into trenVia; --no va a tener mas xq es fin de linea, pero USE lo coge como un Set de 1 elemento
                        else
                            insert(self, self.lineaDeTren.segmentoDeLinea->collect(s : Segmento | self.estacionDelTren.viaIda.segmentoTieneVia)->any(true).viaPerteneceASegmento->select(v|v<>viaAnterior)->asSequence()->last()) into trenVia;
                        end;
                    else
                        if (self.direccion=-1) then
                            --nextStation := self.viaDelTren.estacionIda;
                            delete (self,self.estacionDelTren) from trenEstacion;
                            insert (self,self.viaDelTren.estacionVuelta) into trenEstacion; --self,nextStation
                            delete (self,self.viaDelTren) from trenVia;
                            if (self.estacionDelTren.isEndOfTheLine) then
                                self.direccion:=self.direccion*-1;
                                insert (self,self.estacionDelTren.viaIda->asSequence()->first()) into trenVia; --no va a tener mas xq es fin de linea, pero USE lo coge como un Set de 1 elemento
                            else
                                insert(self, self.lineaDeTren.segmentoDeLinea->collect(s : Segmento | self.estacionDelTren.viaIda.segmentoTieneVia)->any(true).viaPerteneceASegmento->select(v|v<>viaAnterior and v.segmentoTieneVia<>viaAnterior.segmentoTieneVia)->asSequence()->first()) into trenVia;
                            end;
                        end;
                    end;
                else
                    if self.isOutOfOrder=true then
                        self.reparar();
                    end;
                end;
            else -- Los trenes deben esperar 1 min en las estaciones
                self.stopTime:=self.stopTime + self.clock.resolution;
                if self.stopTime = 60 then
                    self.stopTime := 0;
                    self.move();
                end;
            end;         
        end

        -- Un tren tarda 1 hora en ser reparado
        reparar()
        begin
            self.stopTime:=self.stopTime + self.clock.resolution;
            if self.stopTime = 3600 then
                self.isOutOfOrder := false;
                self.stopTime := 0;
                self.move();
            end;
        end

        -- Operación para averiar el tren
        averiar()
        begin
            self.isOutOfOrder := true;
        end
end

class Linea
end

class Via
    attributes
    ocupado : Boolean derive: self.trenEnVia <> null
end

class Segmento
end
-- 
association trenVia between
Tren[0..1] role trenEnVia
Via[0..1] role viaDelTren
end

association trenEstacion between
Tren[0..*] role trenEnEstacion
Estacion[0..1] role estacionDelTren
end

association trenLinea between
Tren[0..*] role trenDeLinea
Linea[0..1] role lineaDeTren
end

aggregation segmentoPerteneceALinea between
Linea[1..*] role lineaDelSegmento
Segmento[1..*] role segmentoDeLinea
end

composition viasDelSegmento between
Segmento[1] role segmentoTieneVia
Via[2] role viaPerteneceASegmento
end

association estacionViaIda between
Estacion[1] role estacionIda
Via[1..*] role viaIda
end

association estacionViaVuelta between
Estacion[1] role estacionVuelta
Via[1..*] role viaVuelta
end


--
constraints

-- En esta contraint comprobamos que la estacion de salida y la de destino no sean la misma

--context segmentoEstacion inv DiferentesEstaciones:
--    self.estacionSalida <> self.estacionDestino

-- Comprobaremos que haya como maximo un tren por via en cada sentido

--context Via inv UnTrenPorVia:
    --Via.allInstances()->forAll(vias | vias.trenIda->size() <= 1) and
    --Via.allInstances()->forAll(vias | vias.trenVuelta->size() <= 1)

-- Numero de lineas mayor que cero

context Linea inv LineasMayorQueCero:
    Linea.allInstances()->size() > 0

-- Numero de segmentos mayor que cero para cada linea

--context Linea inv SegmentosMayorQueCero:
--    Linea.allInstances().segmentoEstacion->size() > 0

-- El número de estaciones en una línea es mayor o igual que 2 (si una linea tiene un número de segmentos mayor que 0, entendemos que tendrá como mínimo 2 estaciones conectadas
-- por el segmento, asique la restricción que implementaremos será que si SegmentosMayorQueCero -> relacion Estacion-Estacion no está "vacía")

--context Linea inv nEstacionesMayorQueDos:
--    self.segmentoEstacion->size() > 0 implies self.segmentoEstacion->forAll(s | s.estacionDestino->notEmpty() and s.estacionSalida->notEmpty())









